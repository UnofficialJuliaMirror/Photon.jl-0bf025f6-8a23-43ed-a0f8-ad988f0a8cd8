

"""
Transformers enable you to transform the output generated by a datasets.
They can be easily chained together and the result is again a Dataset.

```julia
ds = SomeDataset(...)
ds = ds |> Transformer1(...) |> Transformer2(...) |> Transformer3(...)
dl = Dataloader(ds)
```
"""
abstract type Transformer <: Dataset end
Base.length(t::Transformer) = length(t.ds)
function (t::Transformer)(ds::Dataset)
    t.ds = ds
    return t
end


"""
Add noise to samples in a dataset.

# Usage

```julia
ds = TestDataset((28,28,1),(10,),100)
ds = ds |> NoiseTransformer(noiselevel=0.05)
```
"""
mutable struct NoisingTransfomer <: Transformer
    ds::Union{Dataset, Nothing}
	noiselevel
	axis

    NoisingTransfomer(noiselevel=0.01; axis=[:X]) = new(nothing,noiselevel,axis)
end

genNoise(arr::AbstractArray, level::Number) = randn(eltype(arr), size(arr)) .* level

function Base.getindex(t::NoisingTransfomer, idx)
	X,Y = t.ds[idx]
	if :X in t.axis
		X += genNoise(X, t.noiselevel)
	end

	if :Y in t.axis
		Y += genNoise(Y, t.noiselevel)
	end

	return (X,Y)
end


"""
Randomly crop an image in the shape of WxHxC to a certain size.

# Usage

```julia
# Only crop X
ds = TestDataset((100,100,3),(10,),100)
ds = ds |> ImageCrop((50,50))


# Crop both X and Y
ds = TestDataset((100,100,3),(50,50,3),100)
ds = ds |> ImageCrop((50,50), (20,20))
```

"""
mutable struct ImageCrop <: Transformer
    ds::Union{Dataset, Nothing}
	shapeX
	shapeY

    ImageCrop(shapeX , shapeY=nothing) = new(nothing,shapeX, shapeY)
end

function imageCrop(arr::AbstractArray,shape)
	maxX = size(arr,1) - shape[1]
	maxY = size(arr,2) - shape[2]
	offX = rand(1:maxX)
	offY = rand(1:maxY)
	arr[offX:offX+shape[1]-1,offY:offY+shape[2]-1, :]
end


function Base.getindex(t::ImageCrop, idx)
	X,Y = t.ds[idx]
	if t.shapeX != nothing
		X = imageCrop(X, t.shapeX)
	end

	if t.shapeY != nothing
		Y = imageCrop(Y, t.shapeY)
	end

	return (X,Y)
end



function onehot(x, labels, dtype::Type)
	result = zeros(dtype, length(labels))
    result[findfirst(x .== labels)] = 1
    result
end


function onehot(X::AbstractArray, labels, dtype::Type)
	result = zeros(dtype, length(labels))
	for x in X
		result[findfirst(x .== labels)] = 1
	end
	result
end


"""
OneHot transformer for a single sample. Uses
the onehot function to perform the actual transoformation.

Supports both single and multi class encoding:

	5 => [0,0,0,0,0,1,0,0,0,0]
	[5,7] => [0,0,0,0,0,1,0,1,0,0]

# Usage

```julia
ds = mnistds() |> OneHotEncoder(0:9)
```
"""
mutable struct OneHotEncoder <: Transformer
    ds::Union{Dataset, Nothing}
	labels
	axis
	dtype::Type

    OneHotEncoder(labels; axis=[:Y], dtype=getContext().dtype) =
		new(nothing, labels, axis, dtype)
end


function Base.getindex(t::OneHotEncoder, idx)
	X,Y = t.ds[idx]
	if :X in t.axis
		X = onehot(X, t.labels, t.dtype)
	end

	if :Y in t.axis
		Y = onehot(Y, t.labels, t.dtype)
	end

	return (X,Y)
end



#=
# MiniBatch
=#

function update_mb!(arr::AbstractArray, elem::AbstractArray, idx::Int)
	@assert size(arr)[1:end-1] == size(elem) "$(size(arr)) $(size(elem))"
	idxs = Base.OneTo.(size(elem))
	arr[idxs..., idx] = elem
end


function update_mb!(t::Tuple, elems::Tuple, idx::Int)
	@assert length(t) == length(elems)
	for (arr,elem) in zip(t,elems)
		update_mb!(arr, elem, idx)
	end
end

# Create a minibatch that has a similar size to the structure returned
# from the dataset.
create_mb(arr::AbstractArray, batchsize) = similar(arr, size(arr)..., batchsize)
create_mb(t::Tuple, batchsize)= Tuple(collect(create_mb(elem, batchsize) for elem in t))

"""
A dataloader can be passed to the fit! function as data provider. It will call
a dataset to get a single sample and combines them into a minibatch. The dataloader
itself is an iterator.

It will do this using threading, so when a dataset will read some samples from disk
this won't become a botttleneck.

Example:

	ds = ImageDataset(filenames,labels)
	dl = Dataloader(ds, 16, shuffle=false)
	fit!(workout, dl)

"""
mutable struct MiniBatch <: Transformer
    ds::Union{Dataset, Nothing}
    batchsize::Int
    shuffle::Bool

    MiniBatch(batchsize=8; shuffle=true) =
        new(nothing, batchsize, shuffle)
end

Base.length(dl::MiniBatch) = length(dl.ds) รท dl.batchsize

function Base.iterate(dl::MiniBatch, state=undef)
    maxl = length(dl.ds)
    bs = dl.batchsize

    if state == undef
        idxs = dl.shuffle ? Random.shuffle(1:maxl) : 1:max1
        state = (idxs,1)
    end
    idxs, count = state

    if count > (maxl-bs) return nothing end

	l = Threads.SpinLock()
	minibatch = nothing

    Threads.@threads for i in 1:bs

		idx = i + count - 1
		sample = dl.ds[idx]
		@assert sample isa Tuple "Datasets should return Tuples, not $(typeof(sample))"

		if minibatch == nothing
			Threads.lock(l)
			if minibatch == nothing
				minibatch = create_mb(sample, bs)
			end
			Threads.unlock(l)
		end

		update_mb!(minibatch, sample, i)
    end
	Threads.unlock(l)
    return ((minibatch), (idxs, count + bs))
end
