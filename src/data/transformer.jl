

"""
Transformers enable you to transform the output generated by a datasets.
They can be easily chained together and the result is again a Dataset.

```julia
ds = SomeDataset(...)
ds = ds |> Transformer1(...) |> Transformer2(...) |> Transformer3(...)
dl = Dataloader(ds)
```
"""
abstract type Transformer <: Dataset end
Base.length(t::Transformer) = length(t.ds)
function (t::Transformer)(ds::Dataset)
    t.ds = ds
    return t
end


"""
Add noise to samples in a dataset.

# Usage

```julia
ds = TestDataset((28,28,1),(10,),100)
ds = ds |> NoiseTransformer(noiselevel=0.05)
```
"""
mutable struct NoisingTransfomer <: Transformer
    ds::Union{Dataset, Nothing}
	noiselevel
	axis

    NoisingTransfomer(noiselevel=0.01; axis=[:X]) = new(nothing,noiselevel,axis)
end

genNoise(arr::AbstractArray, level::Number) = randn(eltype(arr), size(arr)) .* level

function Base.getindex(t::NoisingTransfomer, idx)
	X,Y = t.ds[idx]
	if :X in t.axis
		X += genNoise(X, t.noiselevel)
	end

	if :Y in t.axis
		Y += genNoise(Y, t.noiselevel)
	end

	return (X,Y)
end


"""
Randomly crop an image in the shape of WxHxC to a certain size.

# Usage

```julia
# Only crop X
ds = TestDataset((100,100,3),(10,),100)
ds = ds |> ImageCrop((50,50))


# Crop both X and Y
ds = TestDataset((100,100,3),(50,50,3),100)
ds = ds |> ImageCrop((50,50), (20,20))
```

"""
mutable struct ImageCrop <: Transformer
    ds::Union{Dataset, Nothing}
	shapeX
	shapeY

    ImageCrop(shapeX , shapeY=nothing) = new(nothing,shapeX, shapeY)
end

function imageCrop(arr::AbstractArray,shape)
	maxX = size(arr,1) - shape[1]
	maxY = size(arr,2) - shape[2]
	offX = rand(1:maxX)
	offY = rand(1:maxY)
	arr[offX:offX+shape[1]-1,offY:offY+shape[2]-1, :]
end


function Base.getindex(t::ImageCrop, idx)
	X,Y = t.ds[idx]
	if t.shapeX != nothing
		X = imageCrop(X, t.shapeX)
	end

	if t.shapeY != nothing
		Y = imageCrop(Y, t.shapeY)
	end

	return (X,Y)
end



function onehot(x, labels, dtype::Type)
	result = zeros(dtype, length(labels))
    result[findfirst(x .== labels)] = 1
    result
end


function onehot(X::AbstractArray, labels, dtype::Type)
	result = zeros(dtype, length(labels))
	for x in X
		result[findfirst(x .== labels)] = 1
	end
	result
end


"""
OneHot transformer for a single sample. Uses
the onehot function to perform the actual transoformation.

Supports both single and multi class encoding:

	5 => [0,0,0,0,0,1,0,0,0,0]
	[5,7] => [0,0,0,0,0,1,0,1,0,0]

# Usage

```julia
ds = mnistds() |> OneHotEncoder(0:9)
```
"""
mutable struct OneHotEncoder <: Transformer
    ds::Union{Dataset, Nothing}
	labels
	axis
	dtype::Type

    OneHotEncoder(labels; axis=[:Y], dtype=getContext().dtype) =
		new(nothing, labels, axis, dtype)
end


function Base.getindex(t::OneHotEncoder, idx)
	X,Y = t.ds[idx]
	if :X in t.axis
		X = onehot(X, t.labels, t.dtype)
	end

	if :Y in t.axis
		Y = onehot(Y, t.labels, t.dtype)
	end

	return (X,Y)
end
